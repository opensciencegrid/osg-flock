#!/bin/bash
#
# This script selects a default image for a glidein. In the fe config,
# specify a distribution for both regular and gpu slots. Example:
#
#   <attr name="OSG_DEFAULT_CONTAINER_DISTRIBUTION" glidein_publish="False" job_publish="False" parameter="True" type="string" value="25%__opensciencegrid/osgvo-el7:latest 25%__opensciencegrid/osgvo-ubuntu-18.04:latest 25%__opensciencegrid/osgvo-el8:latest 25%__opensciencegrid/osgvo-ubuntu-20.04:latest"/>
#   <attr name="OSG_DEFAULT_CONTAINER_DISTRIBUTION_GPU" glidein_publish="False" job_publish="False" parameter="True" type="string" value="100%__opensciencegrid/osgvo-el7-cuda10:latest"/>
#

glidein_config="$1"
export glidein_config

# make sure we do not put images in /tmp
export TMPDIR="$PWD/tmp"
mkdir -p $TMPDIR

function get_glidein_config_value {
    # extracts a config attribute value from 
    # $1 is the attribute key
    CF=$glidein_config
    if [ "$glidein_config" = "NONE" ]; then
        CF="$PWD/glidein_config"
    fi
    KEY="$1"
    VALUE=`(cat $CF | grep "^$KEY " | tail -n 1 | sed "s/^$KEY //") 2>/dev/null`
    echo "$VALUE"
}

function determine_default_container_image {
    # Selects a default image to use if a job does not specify
    # an image to use. The new style to specify this is with an
    # attribute named OSG_DEFAULT_CONTAINER_DISTRIBUTION
    # Example:
    # 70%__opensciencegrid/osgvo-el7:latest 20%__opensciencegrid/osgvo-el6:latest 8%__opensciencegrid/osgvo-ubuntu-18.04:latest 2%__opensciencegrid/osgvo-debian-10:latest 

    OSG_DEFAULT_CONTAINER_DISTRIBUTION=`get_glidein_config_value OSG_DEFAULT_CONTAINER_DISTRIBUTION`
    OSG_SINGULARITY_EL7_PERCENT=`get_glidein_config_value OSG_SINGULARITY_EL7_PERCENT`

    # if we are given GPUs, pick up GPU specific images
    if [ "x$CUDA_VISIBLE_DEVICES" != "x" -o "x$NVIDIA_VISIBLE_DEVICES" != "x" ]; then
        OSG_DEFAULT_CONTAINER_DISTRIBUTION=`get_glidein_config_value OSG_DEFAULT_CONTAINER_DISTRIBUTION_GPU`
    fi

    SELECTED_IMAGE=""
    if [ "x$OSG_DEFAULT_CONTAINER_DISTRIBUTION" != "x" ]; then
        # new style - weighted random selection
        TARGET=$(($RANDOM % 100 + 1))
        TOTAL_PERCENT=0
        for ENTRY in $OSG_DEFAULT_CONTAINER_DISTRIBUTION; do
            PERCENT=`echo $ENTRY | sed 's/%__.*//'`
            IMAGE=`echo $ENTRY | sed 's/.*%__//'`
            # we just need to track the upper limit
            TOTAL_PERCENT=$(($TOTAL_PERCENT + $PERCENT))
            if [ $TARGET -le $TOTAL_PERCENT ]; then
                SELECTED_IMAGE=$IMAGE
                break
            fi
        done
    fi

    # if everything else fails, use EL7
    if [ "x$SELECTED_IMAGE" = "x" ]; then
        if [ "x$CUDA_VISIBLE_DEVICES" != "x" -o "x$NVIDIA_VISIBLE_DEVICES" != "x" ]; then
            SELECTED_IMAGE="opensciencegrid/osgvo-el7-cuda10:latest"
        else
            SELECTED_IMAGE="opensciencegrid/osgvo-el7:latest"
        fi
    fi

    # Should we use CVMFS or pull images directly?

    # Set image storage location via $IMAGES_DIR in the environment
    # or IMAGES_DIR in the glidein config
    [[ -n $IMAGES_DIR ]] || IMAGES_DIR=$(get_glidein_config_value IMAGES_DIR)
    [[ -n $IMAGES_DIR ]] || IMAGES_DIR=$PWD
    mkdir -p "$IMAGES_DIR"
    (( disk_free=$(df -kP "$IMAGES_DIR" 2>/dev/null | awk '{if (NR==2) print $4}') ))
    disk_free_gb=$(($disk_free / 1024 / 1024))
    pull_images=-1
    is_itb=$(get_glidein_config_value Is_ITB_Site)
    entry_name=$(get_glidein_config_value GLIDEIN_Entry_Name)
    singularity_can_use_sif=0
    
    # Make an images subdir and symlink to it from the pilot dir
    # The subdir will contain the hostname so we can read the link to find out what host it's on
    IMAGES_SUBDIR=$IMAGES_DIR/images-$(hostname)/
    mkdir -p "$IMAGES_SUBDIR"
    if ! echo x > "$IMAGES_SUBDIR/.test" 2>&1; then
        info "Not allowing non-CVMFS images, as we couldn't write to the images dir ($IMAGES_SUBDIR)"
        pull_images=0  # So close!
    fi
    rm -f "$IMAGES_SUBDIR/.test"
    ln -snf "$IMAGES_SUBDIR" images

    # the images dir is required here, as we want to keep a copy of the image for this test
    if check_singularity_sif_support; then
        singularity_can_use_sif=1
    fi

    if [[ $pull_images -ge 0 ]]; then
        # decision already made
        :
    elif (uname -r | egrep '^3\.') >/dev/null 2>&1; then
        # do not allow .sif images on 3.x kernels (OSPOOL-18)
        info "Not allowing non-CVMFS images because of the kernel version"
        pull_images=0
    elif (echo "x$entry_name" | egrep "OSG_CHTC-canary2|Syracuse") >/dev/null 2>&1; then
        info "Not allowing non-CVMFS images, as the site is on the deny list ($entry_name)"
        pull_images=0
    elif [ $singularity_can_use_sif = 0 ]; then
        # Forbid running non-CVMFS images if they have to be unpacked first.
        # May change later if we find sites where this is "safe."
        info "Not allowing non-CVMFS images, as Singularity cannot directly run SIF files"
        pull_images=0
    elif [[ $disk_free_gb -lt 10 ]]; then
        info "Not allowing non-CVMFS images, as the site does not have enough free disk space on the images volume ($disk_free_gb GBs)"
        pull_images=0
    elif [ "x$ALLOW_NONCVMFS_IMAGES" != "x" ]; then
        info "Allowing non-CVMFS images because \$ALLOW_NONCVMFS_IMAGES is set"
        pull_images=1
    elif (echo "x$entry_name" | egrep "Clemson|ELSA|ODU-Ubuntu|Stampede2|UTC-Epyc") >/dev/null 2>&1; then
        info "Allowing non-CVMFS images because of the entry name: $entry_name"
        pull_images=1
    elif ! (ls /cvmfs/singularity.opensciencegrid.org/) >/dev/null 2>&1; then
        info "Allowing non-CVMFS images because /cvmfs/singularity.opensciencegrid.org/ is not available"
        pull_images=1
    fi
    if [ $pull_images = 1 ]; then
        # pull the image into a Singularity SIF file
        IMAGE_NAME=$(echo "$SELECTED_IMAGE" | sed 's;[:/];__;g')
        IMAGE_PATH=$PWD/images/$IMAGE_NAME.sif
        WEEK=$(date +'%V')
        OSDF_URL=osdf:///ospool/uc-shared/public/OSG-Staff/images/$WEEK/sif/$IMAGE_NAME.sif
        HTTP_URL=http://ospool-images.osgprod.tempest.chtc.io/$WEEK/sif/$IMAGE_NAME.sif
        (osdf_download $IMAGE_PATH $OSDF_URL \
            || http_download $IMAGE_PATH $HTTP_URL \
            || singularity pull --force $IMAGE_PATH docker://hub.opensciencegrid.org/$SELECTED_IMAGE) >$IMAGE_PATH.log 2>&1
        if [ $? = 0 ]; then
            advertise ALLOW_NONCVMFS_IMAGES "True" "C"
            advertise GWMS_SINGULARITY_PULL_IMAGES "True" "C"
            advertise SINGULARITY_IMAGES_DICT "default:$IMAGE_PATH" "S"
            advertise REQUIRED_OS "default" "S"
            advertise OSG_DEFAULT_SINGULARITY_IMAGE "$IMAGE_PATH" "S"
            return 0
        else
            my_warn "Failed to pull $SELECTED_IMAGE; falling back to CVMFS"
        fi
    fi

    # prepend the base bath
    SELECTED_IMAGE="/cvmfs/singularity.opensciencegrid.org/$SELECTED_IMAGE"
    advertise SINGULARITY_IMAGES_DICT "default:$SELECTED_IMAGE" "S"
    advertise OSG_DEFAULT_SINGULARITY_IMAGE "$SELECTED_IMAGE" "S"
    advertise REQUIRED_OS "default" "S"
}

if [ "$glidein_config" != "NONE" ]; then
    ###########################################################
    # import advertise and add_condor_vars_line functions
    if [ "x$add_config_line_source" = "x" ]; then
        export add_config_line_source=`grep '^ADD_CONFIG_LINE_SOURCE ' $glidein_config | awk '{print $2}'`
        export condor_vars_file=`grep -i "^CONDOR_VARS_FILE " $glidein_config | awk '{print $2}'`
    fi

    # full path is problematic as sometimes we are inside a container - however, looks like
    # the file is always named "add_config_line.source", so use that
    add_config_line_source=$PWD/add_config_line.source

    source $add_config_line_source

    # XXX Patch over add_config_line() with a safer version
    # This will be fixed in gWMS 3.9.6
    add_config_line() {
        # Ignore the call if the exact config line is already in there
        if ! grep -q "^${*}$" "${glidein_config}"; then
            # Use temporary files to make sure multiple add_config_line() calls don't clobber
            # the glidein_config.
            local r="$(head -c16 /dev/urandom | base64 -w0 - | tr / _)"
            local tmp_config1="${glidein_config}.$r.1"
            local tmp_config2="${glidein_config}.$r.2"

            # Copy the glidein config so it doesn't get modified while we grep out the old value
            if ! cp -p "${glidein_config}" "${tmp_config1}"; then
                warn "Error writing ${tmp_config1}"
                rm -f "${tmp_config1}"
                exit 1
            fi
            grep -v "^$1 " "${tmp_config1}" > "${tmp_config2}"
            rm -f "${tmp_config1}"
            if [ ! -f "${tmp_config2}" ]; then
                warn "Error creating ${tmp_config2}"
                exit 1
            fi
            # NOTE that parameters are flattened if not quoted, if there are blanks they are separated by single space
            echo "$@" >> "${tmp_config2}"

            # Replace glidein config atomically
            if ! mv -f "${tmp_config2}" "${glidein_config}"; then
                warn "Error updating ${glidein_config} from ${tmp_config2}"
                rm -f "${tmp_config2}"
                exit 1
            fi
        fi
    }
    # XXX End add_config_line() patch
fi

# source our helpers
group_dir=$(get_glidein_config_value GLIDECLIENT_GROUP_WORK_DIR)
if [ -e "$group_dir/itb-ospool-lib" ]; then
    source "$group_dir/itb-ospool-lib"
else
    source "$group_dir/ospool-lib"
fi

determine_default_container_image


